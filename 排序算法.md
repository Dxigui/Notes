## 选择排序

找到数组中最小的那个元素,然后将它和数组的第一个元素交换位置(如果第一个元素就是最小的元素,那么它就和自己交换),再次,在剩下的元素中找多最小的元素,将它与数组的第二个元素交换位置,以此往复,知道将整个数组排序完.

> 对于张队为 **N** 的数组,选择排序需要大约 **N^2/2**  次比较和 **N** 次交换
>
> 证明:
>
> 假设一个长度为 5 的数组 `A=[6,2,5,3,7]`
>
> 1. 初始设置最小值为 `A[0]`,`min_index=0`
>
>    依次将 `A[0]` 依次与其他数判断大小,如果 `A[0]` 大,则交换 `min_index`, 进行了 **5-1 = 4** 次比较,比较结束后最小值和 `A[0]` 交换位置, 交换次数 **1**.
>
> 2. 第二轮设最小值为 `A[1]` , `min_index=1`
>
>    `A[0]` 已经选出,则不用进行比较,只需 `A[1]` 和其后面的进行比较,最后进行比较的次数为 **5-1-1 =3** ,交换次数 **1**.
>
> 3. 第三轮最小值 `A[2]`, `min_index=2`
>
>    比较次数: **5-1-2 = 2**
>
>    交换次数: 1
>
> 4. 第四轮 `A[3]`, `min_index=3`
>
>    比较次数: 5-1-3 = 1
>
>    交换次数: 1
>
> 5. 第五轮 `A[4]`, `min_index=4`
>
>    比较次数: 5-1-4 = 0
>
>    交换次数: 1
>
> 总结:
>
> **0** 到 **N-1** 的任意 **i** 都会进行一次交换和 **N-1-i** 次交换, 所以 **N** 次比较有 **(N-1)+(N-2)+...+2+1+0=N(N-1)/2** 次比较(约 **N^2/2**)



代码实现:

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

class Solution(object):
    def __init__(self, A):
        self.A = A
    def less(self, num_a, num_b):
        if num_a <= num_b:
            return True
        else:
            return False
    def exch(self, i, min_index):
        self.A[i], self.A[min_index] = self.A[min_index], self.A[i]
    def show(self):
        print(self.A)
    def isSorted(self):
        for i in range(1, len(self.A)):
            if self.less(a[i-1], a[i]):
                continue
            else:
                print(False)
                return
        print(True)
    def choiceSort(self):
        length = len(self.A)
        for i in range(length):
            min_index = i
            for j in range(i+1, length):
                if self.less(a[j], a[min_index]):
                    min_index = j
            self.exch(i, min_index)
            
```

